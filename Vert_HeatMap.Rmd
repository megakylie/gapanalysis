---
title: "R Notebook"
output: console
editor_options: 
  chunk_output_type: console
---

This R Markdown is to make collection intensity heat maps for the amphibian data. The first round I did it on both the collection and observation (iNaturalist) data combined. These feel like they should be separate, maybe just collections since we have the inat maps 

```{r}
### --- Load Packages --- ###
library(tidyverse)
library(raster)
library(sf)
library(sp)
library(rgdal)
library(raster)
library(rgeos)
library(CoordinateCleaner)
library(scrubr)
library(scales)
library(rasterVis)

```

#Aves data clean up 
```{r import bird data}

## importing individual datasets as well so can pull out locality info 
#using inat3, ebird_new2 chis_onlyegg2, sbmnh_obs4, and sbmnh_col4.
library(readxl)
aves_chis <- read_csv("aves/aves_chis_onlyeggs2.csv")
aves_sbmnh_col <- read_excel("aves/aves_sbmnh_col.xlsx")

```


##Aves Step 2. Combine datasets. Lat and Long included. 
```{r selecting and combining}

aves_chis_combine <- aves_chis %>%
  rename(latitude = "decimalLatitude", longitude="decimalLongitude", year="year_", month="month_", type="collectionType") %>%
  select(id, source, month, year, island, class, acceptedFamily, acceptedGenus, acceptedName, latitude, longitude, type, family, genus, scientificName, locality) %>%
  add_column(type2="Collection: Egg/Nest", type3="Collection")

aves_sbmnh_col_combine <- aves_sbmnh_col %>%
  rename(latitude = "decimalLatitude", longitude="decimalLongitude", type="collectionType2") %>%
  select(id, source, month, year, island, class, acceptedFamily, acceptedGenus, acceptedName, latitude, longitude, type, family, genus, scientificName, locality) %>%
  add_column(type2="Collection: Specimen", type3="Collection")

aves_master_coll = rbind(aves_chis_combine, aves_sbmnh_col_combine) %>%
  # reorder the island names to show up N -> S on list
  mutate(island = fct_relevel(island, "San Miguel", "Santa Rosa", "Santa Cruz", "Anacapa", "Santa Barbara", "Santa Catalina", "San Nicolas", "San Clemente"))
#filter out all NA rows 
aves_master_coll <- filter(aves_master_coll, rowSums(is.na(aves_master_coll)) != ncol(aves_master_coll)) # Apply 

```


```{r Cleaning up data Aves}
# create a dataframe of all complete cases of name, lat/long, island, and year with unique lat/long and locality to check, made a list of ones to remove from excel sheet

all_data_coords_aves_unclean <- aves_master_coll %>%
  dplyr::filter(!is.na(latitude), !is.na(longitude))

aves_data = all_data_coords_aves_unclean %>% 
  unite("latlong", latitude:longitude, remove=FALSE, sep="")

avescoord= table(aves_data$latlong)
avescoord = as.data.frame.table(avescoord) %>% rename(latlong="Var1")

aves_latlong = aves_data %>% select(id, island, latlong, latitude, longitude, locality, year)
avescoord2 = left_join(avescoord, aves_latlong) %>% rename(locality_latlong ="latlong")
avescoord3 = distinct(avescoord2, across(contains("locality")), .keep_all=TRUE) %>% add_column(taxa="aves")

write_csv(avescoord3, "coordinates/Aves_coordinates_locality.csv")

#download list of ones to remove
aves_coord_remove = read_csv("coordinates/Aves_coordinates_remove.csv")

all_data_coords_aves = anti_join(all_data_coords_aves, aves_coord_remove)
all_data_coord_aves_removedlist = semi_join(all_data_coords_aves, aves_coord_remove)
```

```{r Actually Heat map code}
############### drop points with meaningless coords - this removes any specimens that have long/lats that are not in the vicinity of the islands

########## Remove obvious georeferencing errors by hand- the 'identify' function allows you to click on a scatterplot (ie distribution map) to identify individual points. This is nice if you have a few coords out in the ocean. If you have a bunch, you'll probably want to do an intersection with island polygons, but I didn't have an island polygon file when I was doing this (the maps I used are line shapefiles, not polygons)

## JL: will do this with the coord cleaner package 
all_data_coords = all_data_coords_aves
flags <- clean_coordinates(x = all_data_coords, lon = "longitude", lat = "latitude",
                          species = "acceptedName",
                          tests = c("capitals", "centroids", "equal","gbif", "institutions",
                                     "zeros"))
all_data_coords <- all_data_coords[flags$.summary,] 

all_data_coords <- all_data_coords %>%
  filter(longitude <= -118, longitude >= -120.5,
         latitude <= 34.1, latitude >= 32.7)

  
plot(all_data_coords$longitude, all_data_coords$latitude, asp=1)

# using Ben's modified code and a shapefile found online to isolate counties of interest, 
# Albers projection is used in order to have grids in km^2


counties <- readOGR("Heatmap_files", layer="cnty24k09_1_line")
chis_counties <- counties[counties$NAME%in%c("Ventura", "Santa Barbara","Los Angeles","San Diego","Orange")]
is.map <- crop(counties, extent(-1.5e+05,2.5e+05,-6e+05,-4e+05))

plot(is.map, col="black")
rm(counties)
rm(chis_counties)

####### Project Long + Lat Coords into Albers (Island maps are in Albers)
P4S.latlon <- CRS("+proj=longlat +datum=WGS84")
new_proj <- "+proj=aea +lat_1=34 +lat_2=40.5 +lat_0=0 +lon_0=-120 +x_0=0 +y_0=-4000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"

sp <- SpatialPointsDataFrame(coords = cbind(as.numeric(all_data_coords_aves$longitude),
                                            as.numeric(all_data_coords_aves$latitude)), 
                             data = all_data_coords, proj4string = P4S.latlon)
pointsX <- spTransform(sp, CRS(new_proj))


# attach projected points to 'all_data'
all_data_coords1 <- cbind(all_data_coords_aves,pointsX@coords) %>%
  mutate(Lat_alb = coords.x2,
         Lon_alb = coords.x1)

### --- Remove things in the middle of the ocean --- ###
  
# Import island polygons
ibis <- st_read("Heatmap_files/Master_Islands.shp")

chis_ibis <- ibis %>%
  filter(ISL_NAME %in% c("Santa Rosa", "Santa Cruz", "San Miguel", "Anacapa", "San Clemente", "Santa Barbara", "Santa Catalina", "San Nicolas")) 

chis_ibis <- st_transform(chis_ibis, crs = st_crs(new_proj))

# Remove points waaaaaay off of the islands, josie-style
all_data_coords2 <- st_as_sf(all_data_coords1, coords = c("coords.x1", "coords.x2"), crs = new_proj)

all_data_coords3 <- st_join(all_data_coords2, chis_ibis, join = st_intersects) %>%
  filter(!is.na(island))

ggplot(chis_ibis) +
  geom_sf(data = all_data_coords3, color = "red", size = 0.3) +
  geom_sf(fill = alpha("black", 0.2)) 

write_csv(all_data_coords3, "Aves/all_data_coords.csv")
```

```{r grid data download Aves}
################# Grid maps ############
# Matrix indicating which cells from islandRaster correspond to which island
island.cells <- read.csv("Heatmap_files/islandCells.csv")

# binary raster of the islands and coastline
isl.rast <- raster("Heatmap_files/islandRaster.asc")
 
# Data
occ <- read_csv("Aves/all_data_coords.csv") 

# The xlim & ylim (in albers) for plotting each island
plot.lims <- read.csv("Heatmap_files/islandPlotLimits.csv")

```


#Make the maps
```{r grid making}
# Lines for island edges
counties <- readOGR("Heatmap_files", layer="cnty24k09_1_line")
chis_counties <- counties[counties$NAME%in%c("Ventura", "Santa Barbara","Los Angeles","San Diego","Orange")]
is.map <- crop(counties, extent(-1.5e+05,2.5e+05,-6e+05,-4e+05))


isl.names <- c("Anacapa","Santa Cruz","Santa Rosa","San Miguel",
"Santa Catalina","San Clemente","San Nicolas","Santa Barbara")

### Analysis - Build Tables/Rasters
# get cellIDs for each occurrence
cellID <- cellFromXY(isl.rast, xy = cbind(occ$Lon_alb, occ$Lat_alb))
occ <- cbind(occ,cellID); rm(cellID)
length(unique(occ$cellID))

# make a big grid
w <- which(!is.na(isl.rast[]))
taxa <- sort(unique(occ$acceptedName))
taxGrid <- matrix(nrow=length(taxa),ncol=length(w))
colnames(taxGrid) <- w
rownames(taxGrid) <- taxa
taxGrid[] <- 0

for(i in 1:dim(taxGrid)[1]){
	spCells <- occ$cellID[occ$acceptedName==taxa[i]]
	for(j in 1:length(spCells)){
		taxGrid[i,w %in% spCells[j]]<-taxGrid[i,w %in% spCells[j]]+1
	}
}

# make a binary version (this is presence/abs of each sp in each cell rather than num of collections of each sp in each cell)
binaryGrid <- taxGrid
binaryGrid[binaryGrid>0] <- 1

# make corresponding rasters
rich.rast <- isl.rast
rich.rast[rich.rast == 1] <- 0
rich.rast[w] <- colSums(binaryGrid)
coll.rast <- isl.rast
coll.rast[coll.rast == 1] <- 0
coll.rast[w] <- colSums(taxGrid)

plot(rich.rast)
plot(coll.rast)

### Calculate % Empty and Redundancy for Islands ##

k=1
is.cel <- island.cells$isl.rastCell[island.cells$island == isl.names[k]]
rich.cel <- rich.rast[is.cel]
coll.cel <- coll.rast[is.cel]

k=2
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=3
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=4
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=5
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=6
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=7
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=8
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]


coll.Summary<-matrix(nrow=8,ncol=9)

# Red =  1-R/N
rownames(coll.Summary) <- isl.names
colnames(coll.Summary) <- c("totCells","totColls","totRich","Empty","perEmpty",
                            "mnRich","mnColl","mnRedund","mnRedundwE")
for(i in 1:8){
	is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[i]]
	rich.cel<-rich.rast[is.cel]
	coll.cel<-coll.rast[is.cel]
	coll.Summary[i,"totCells"] <- length(rich.cel)
	coll.Summary[i,"totColls"] <- sum(coll.cel)
	coll.Summary[i,"Empty"] <- length(which(rich.cel==0))
	coll.Summary[i,"perEmpty"] <- round(length(which(rich.cel==0))/length(rich.cel),3)
	coll.Summary[i,"mnRich"] <- mean(rich.cel[rich.cel!=0])
	coll.Summary[i,"mnColl"] <- mean(coll.cel[rich.cel!=0])
	coll.Summary[i,"totRich"] <- length(unique(occ$Sci_Name[occ$isl_name==isl.names[i]]))
	coll.Summary[i,"mnRedund"] <- round(mean(1-(rich.cel[rich.cel!=0]/coll.cel[rich.cel!=0])),3)
	coll.Summary[i,"mnRedundwE"] <- round(1/mean((coll.cel-rich.cel)),3)
}

sum_table <- as.data.frame(coll.Summary) %>%
  rownames_to_column(var = "island") %>% 
  rename("Island Collections" ="totColls", "1 km cells" ="totCells", "Empty 1 km cells" ="Empty", "Mean records/cell"="mnColl", "Mean redundancy" ="mnRedundwE", "% empty cells"="perEmpty") %>%
  relocate("island", "Island Collections", "1 km cells", "Empty 1 km cells", "% empty cells", "Mean records/cell", "Mean redundancy" )
write.csv(sum_table, "aves/aves_sum_table.csv", na="")

######### Make Grid-based maps ##################
colorfunc <- colorRampPalette(c("gray90","red"))
colRamp <- colorfunc(20)



### Sampling intensity
#anacapa
i=1
plot(coll.rast, col=colRamp, xlim=c(50000,61000), ylim=c(-450000,-440000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#cruz
i=2
plot(coll.rast, col = colRamp, xlim=c(5000,46000), ylim=c(-460000,-420000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#rosa
i=3
plot(coll.rast, col=colRamp, xlim=c(-25000,5000), ylim=c(-470000,-430000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#miguel
i=4
plot(coll.rast, col=colRamp,xlim=c(-45000,-25000),ylim=c(-450000,-430000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19)  
#catalina
i=5
plot(coll.rast, col=colRamp,xlim=c(125000,165000),ylim=c(-530000,-500000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19)  
#clemente
i=6
plot(coll.rast, col=colRamp,xlim=c(125000,160000),ylim=c(-580000,-550000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#nicolas
i=7
plot(coll.rast, col=colRamp,xlim=c(35000,58000),ylim=c(-540000,-520000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#barbara
i=8
sj = plot(coll.rast, col=colRamp,xlim=c(86000,94000),ylim=c(-508000,-500000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19)
sj
```

#Amphibian data

##Amph Step 2. Combine datasets. Lat and Long included. 
```{r selecting and combining}
amph_chis <- read_csv("amphibian/amph_chis.csv")
amph_chis_combine <- amph_chis %>%
  rename(latitude = "decimalLatitude", longitude="decimalLongitude", month="month_", year="year_", id="gbifID") %>%
  select(id, month, year, island...128, class, acceptedGenus, acceptedName, latitude, longitude, locality) %>%
  rename(island = "island...128") %>%
  add_column(source="Cal-IBIS", type="Collection")

```

```{r Cleaning up data Aves}
# create a dataframe of all complete cases of name, lat/long, island, and year with unique lat/long and locality to check, made a list of ones to remove from excel sheet

all_data_coords_amph_unclean <- amph_chis_combine %>%
  dplyr::filter(!is.na(latitude), !is.na(longitude))

amph_data = all_data_coords_amph_unclean %>% 
  unite("latlong", latitude:longitude, remove=FALSE, sep="")

amphcoord= table(amph_data$latlong)
amphcoord = as.data.frame.table(amphcoord) %>% rename(latlong="Var1")

amph_latlong = amph_data %>% select(id, island, latlong, latitude, longitude, locality, year)
amphcoord2 = left_join(amphcoord, amph_latlong) %>% rename(locality_latlong ="latlong")
amphcoord3 = distinct(amphcoord2, across(contains("locality")), .keep_all=TRUE) %>% add_column(taxa="amphibian")

write_csv(amphcoord3, "coordinates/amph_coordinates_locality.csv")

#download list of ones to remove
amph_coord_remove = read_csv("coordinates/amph_coordinates_remove.csv")

all_data_coords_amph = anti_join(all_data_coords_amph, amph_coord_remove)
all_data_coord_amph_removedlist = semi_join(all_data_coords_amph, amph_coord_remove)
```


## Island heat map

```{r Cleaning up data AMPHIBIAN}
# create a dataframe of all complete cases of name, lat/long, island, and year

all_data_coords <- amp_data %>%
  dplyr::filter(!is.na(latitude), !is.na(longitude))

############### drop points with meaningless coords - this removes any specimens that have long/lats that are not in the vicinity of the islands

########## Remove obvious georeferencing errors by hand- the 'identify' function allows you to click on a scatterplot (ie distribution map) to identify individual points. This is nice if you have a few coords out in the ocean. If you have a bunch, you'll probably want to do an intersection with island polygons, but I didn't have an island polygon file when I was doing this (the maps I used are line shapefiles, not polygons)

## JL: will do this with the coord cleaner package 

flags <- clean_coordinates(x = all_data_coords, lon = "longitude", lat = "latitude",
                          species = "acceptedName",
                          tests = c("capitals", "centroids", "equal","gbif", "institutions",
                                     "zeros"))
all_data_coords <- all_data_coords[flags$.summary,] 

all_data_coords <- all_data_coords %>%
  filter(longitude <= -118, longitude >= -120.5,
         latitude <= 34.1, latitude >= 32.7)

  
plot(all_data_coords$longitude, all_data_coords$latitude, asp=1)

# using Ben's modified code and a shapefile found online to isolate counties of interest, 
# Albers projection is used in order to have grids in km^2


counties <- readOGR("Heatmap_files", layer="cnty24k09_1_line")
chis_counties <- counties[counties$NAME%in%c("Ventura", "Santa Barbara","Los Angeles","San Diego","Orange")]
is.map <- crop(counties, extent(-1.5e+05,2.5e+05,-6e+05,-4e+05))

plot(is.map, col="black")
rm(counties)
rm(chis_counties)

####### Project Long + Lat Coords into Albers (Island maps are in Albers)
P4S.latlon <- CRS("+proj=longlat +datum=WGS84")
new_proj <- "+proj=aea +lat_1=34 +lat_2=40.5 +lat_0=0 +lon_0=-120 +x_0=0 +y_0=-4000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"

sp <- SpatialPointsDataFrame(coords = cbind(as.numeric(all_data_coords$longitude),
                                            as.numeric(all_data_coords$latitude)), 
                             data = all_data_coords, proj4string = P4S.latlon)
pointsX <- spTransform(sp, CRS(new_proj))


# attach projected points to 'all_data'
all_data_coords1 <- cbind(all_data_coords,pointsX@coords) %>%
  mutate(Lat_alb = coords.x2,
         Lon_alb = coords.x1)

### --- Remove things in the middle of the ocean --- ###
  
# Import island polygons
ibis <- st_read("Heatmap_files/Master_Islands.shp")

chis_ibis <- ibis %>%
  filter(ISL_NAME %in% c("Santa Rosa", "Santa Cruz", "San Miguel", "Anacapa", "San Clemente", "Santa Barbara", "Santa Catalina", "San Nicolas")) 

chis_ibis <- st_transform(chis_ibis, crs = st_crs(new_proj))

# Remove points waaaaaay off of the islands, josie-style
all_data_coords2 <- st_as_sf(all_data_coords1, coords = c("coords.x1", "coords.x2"), crs = new_proj)

all_data_coords3 <- st_join(all_data_coords2, chis_ibis, join = st_intersects) %>%
  filter(!is.na(island))

ggplot(chis_ibis) +
  geom_sf(data = all_data_coords3, color = "red", size = 0.3) +
  geom_sf(fill = alpha("black", 0.2)) 

write_csv(all_data_coords3, "Amphibian/all_data_coords.csv")
```

```{r grid data download AMPHIBIAN}
################# Grid maps ############
# Matrix indicating which cells from islandRaster correspond to which island
island.cells <- read.csv("Heatmap_files/islandCells.csv")

# binary raster of the islands and coastline
isl.rast <- raster("Heatmap_files/islandRaster.asc")
 
# Data
occ <- read_csv("Amphibian/all_data_coords.csv") 

# The xlim & ylim (in albers) for plotting each island
plot.lims <- read.csv("Heatmap_files/islandPlotLimits.csv")

```

#Make the maps
```{r grid making}
# Lines for island edges
counties <- readOGR("Heatmap_files", layer="cnty24k09_1_line")
chis_counties <- counties[counties$NAME%in%c("Ventura", "Santa Barbara","Los Angeles","San Diego","Orange")]
is.map <- crop(counties, extent(-1.5e+05,2.5e+05,-6e+05,-4e+05))


isl.names <- c("Anacapa","Santa Cruz","Santa Rosa","San Miguel",
"Santa Catalina","San Clemente","San Nicolas","Santa Barbara")

### Analysis - Build Tables/Rasters
# get cellIDs for each occurrence
cellID <- cellFromXY(isl.rast, xy = cbind(occ$Lon_alb, occ$Lat_alb))
occ <- cbind(occ,cellID); rm(cellID)
length(unique(occ$cellID))

# make a big grid
w <- which(!is.na(isl.rast[]))
taxa <- sort(unique(occ$acceptedName))
taxGrid <- matrix(nrow=length(taxa),ncol=length(w))
colnames(taxGrid) <- w
rownames(taxGrid) <- taxa
taxGrid[] <- 0

for(i in 1:dim(taxGrid)[1]){
	spCells <- occ$cellID[occ$acceptedName==taxa[i]]
	for(j in 1:length(spCells)){
		taxGrid[i,w %in% spCells[j]]<-taxGrid[i,w %in% spCells[j]]+1
	}
}

# make a binary version (this is presence/abs of each sp in each cell rather than num of collections of each sp in each cell)
binaryGrid <- taxGrid
binaryGrid[binaryGrid>0] <- 1

# make corresponding rasters
rich.rast <- isl.rast
rich.rast[rich.rast == 1] <- 0
rich.rast[w] <- colSums(binaryGrid)
coll.rast <- isl.rast
coll.rast[coll.rast == 1] <- 0
coll.rast[w] <- colSums(taxGrid)

plot(rich.rast)
plot(coll.rast)

### Calculate % Empty and Redundancy for Islands ##

k=1
is.cel <- island.cells$isl.rastCell[island.cells$island == isl.names[k]]
rich.cel <- rich.rast[is.cel]
coll.cel <- coll.rast[is.cel]

k=2
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=3
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=4
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=5
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=6
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=7
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=8
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]


coll.Summary<-matrix(nrow=8,ncol=9)

# Red =  1-R/N
rownames(coll.Summary) <- isl.names
colnames(coll.Summary) <- c("totCells","totColls","totRich","Empty","perEmpty",
                            "mnRich","mnColl","mnRedund","mnRedundwE")
for(i in 1:8){
	is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[i]]
	rich.cel<-rich.rast[is.cel]
	coll.cel<-coll.rast[is.cel]
	coll.Summary[i,"totCells"] <- length(rich.cel)
	coll.Summary[i,"totColls"] <- sum(coll.cel)
	coll.Summary[i,"Empty"] <- length(which(rich.cel==0))
	coll.Summary[i,"perEmpty"] <- round(length(which(rich.cel==0))/length(rich.cel),3)
	coll.Summary[i,"mnRich"] <- mean(rich.cel[rich.cel!=0])
	coll.Summary[i,"mnColl"] <- mean(coll.cel[rich.cel!=0])
	coll.Summary[i,"totRich"] <- length(unique(occ$Sci_Name[occ$isl_name==isl.names[i]]))
	coll.Summary[i,"mnRedund"] <- round(mean(1-(rich.cel[rich.cel!=0]/coll.cel[rich.cel!=0])),3)
	coll.Summary[i,"mnRedundwE"] <- round(1/mean((coll.cel-rich.cel)),3)
}

sum_table <- as.data.frame(coll.Summary) %>%
  rownames_to_column(var = "island") %>% 
  rename("Island Collections" ="totColls", "1 km cells" ="totCells", "Empty 1 km cells" ="Empty", "Mean records/cell"="mnColl", "Mean redundancy" ="mnRedundwE", "% empty cells"="perEmpty") %>%
  relocate("island", "Island Collections", "1 km cells", "Empty 1 km cells", "% empty cells", "Mean records/cell", "Mean redundancy" )
write.csv(sum_table, "amphibian/AmphibianGraphs/amph_sum_table.csv", na="")

######### Make Grid-based maps ##################
colorfunc <- colorRampPalette(c("gray90","red"))
colRamp <- colorfunc(20)



### Sampling intensity
#anacapa
i=1
plot(coll.rast, col=colRamp, xlim=c(50000,61000), ylim=c(-450000,-440000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#cruz
i=2
plot(coll.rast, col = colRamp, xlim=c(5000,46000), ylim=c(-460000,-420000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#rosa
i=3
plot(coll.rast, col=colRamp, xlim=c(-25000,5000), ylim=c(-470000,-430000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#miguel
i=4
plot(coll.rast, col=colRamp,xlim=c(-45000,-25000),ylim=c(-450000,-430000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19)  
#catalina
i=5
plot(coll.rast, col=colRamp,xlim=c(125000,165000),ylim=c(-530000,-500000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19)  
#clemente
i=6
plot(coll.rast, col=colRamp,xlim=c(125000,160000),ylim=c(-580000,-550000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#nicolas
i=7
plot(coll.rast, col=colRamp,xlim=c(35000,58000),ylim=c(-540000,-520000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#barbara
i=8
plot(coll.rast, col=colRamp,xlim=c(86000,94000),ylim=c(-508000,-500000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19)

```


#REPTILE data

##Rep Step 2. Combine datasets. Lat and Long included. 
```{r selecting and combining}
rep_chis <- read_csv("reptile/rep_chis.csv")

rep_chis_coord <- rep_chis %>%
  rename(latitude = "decimalLatitude", longitude="decimalLongitude", id="gbifID", island="island...128") %>%
  select(id, institutionCode, month, year, island, class, acceptedFamily, acceptedGenus, acceptedName, latitude, longitude, locality) 

```

```{r Cleaning up data Rep}
# create a dataframe of all complete cases of name, lat/long, island, and year with unique lat/long and locality to check, made a list of ones to remove from excel sheet

all_data_coords_rep_unclean <- rep_chis_coord %>%
  dplyr::filter(!is.na(latitude), !is.na(longitude))

rep_data = all_data_coords_rep_unclean %>% 
  unite("latlong", latitude:longitude, remove=FALSE, sep="")

repcoord= table(rep_data$latlong)
repcoord = as.data.frame.table(repcoord) %>% rename(latlong="Var1")

rep_latlong = rep_data %>% select(id, island, latlong, latitude, longitude, locality, year)
repcoord2 = left_join(repcoord, rep_latlong) %>% rename(locality_latlong ="latlong")
repcoord3 = distinct(repcoord2, across(contains("locality")), .keep_all=TRUE) %>% add_column(taxa="reptile")

write_csv(amphcoord3, "coordinates/rep_coordinates_locality.csv")

#download list of ones to remove
rep_coord_remove = read_csv("coordinates/rep_coordinates_remove.csv")

all_data_coords_amph = anti_join(all_data_coords_amph, amph_coord_remove)
all_data_coord_amph_removedlist = semi_join(all_data_coords_amph, amph_coord_remove)
```


## Island heat map

```{r Step 2. Cleaning up data AMPHIBIAN}
# create a dataframe of all complete cases of name, lat/long, island, and year

all_data_coords <- rep_data %>%
  dplyr::filter(!is.na(latitude), !is.na(longitude))

############### drop points with meaningless coords - this removes any specimens that have long/lats that are not in the vicinity of the islands

########## Remove obvious georeferencing errors by hand- the 'identify' function allows you to click on a scatterplot (ie distribution map) to identify individual points. This is nice if you have a few coords out in the ocean. If you have a bunch, you'll probably want to do an intersection with island polygons, but I didn't have an island polygon file when I was doing this (the maps I used are line shapefiles, not polygons)

## JL: will do this with the coord cleaner package 

flags <- clean_coordinates(x = all_data_coords, lon = "longitude", lat = "latitude",
                          species = "acceptedName",
                          tests = c("capitals", "centroids", "equal","gbif", "institutions",
                                     "zeros"))
all_data_coords <- all_data_coords[flags$.summary,] 

all_data_coords <- all_data_coords %>%
  filter(longitude <= -118, longitude >= -120.5,
         latitude <= 34.1, latitude >= 32.7)

  
plot(all_data_coords$longitude, all_data_coords$latitude, asp=1)

# using Ben's modified code and a shapefile found online to isolate counties of interest, 
# Albers projection is used in order to have grids in km^2


counties <- readOGR("Heatmap_files", layer="cnty24k09_1_line")
chis_counties <- counties[counties$NAME%in%c("Ventura", "Santa Barbara","Los Angeles","San Diego","Orange")]
is.map <- crop(counties, extent(-1.5e+05,2.5e+05,-6e+05,-4e+05))

plot(is.map, col="black")
rm(counties)
rm(chis_counties)

####### Project Long + Lat Coords into Albers (Island maps are in Albers)
P4S.latlon <- CRS("+proj=longlat +datum=WGS84")
new_proj <- "+proj=aea +lat_1=34 +lat_2=40.5 +lat_0=0 +lon_0=-120 +x_0=0 +y_0=-4000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"

sp <- SpatialPointsDataFrame(coords = cbind(as.numeric(all_data_coords$longitude),
                                            as.numeric(all_data_coords$latitude)), 
                             data = all_data_coords, proj4string = P4S.latlon)
pointsX <- spTransform(sp, CRS(new_proj))


# attach projected points to 'all_data'
all_data_coords1 <- cbind(all_data_coords,pointsX@coords) %>%
  mutate(Lat_alb = coords.x2,
         Lon_alb = coords.x1)

### --- Remove things in the middle of the ocean --- ###
  
# Import island polygons
ibis <- st_read("Heatmap_files/Master_Islands.shp")

chis_ibis <- ibis %>%
  filter(ISL_NAME %in% c("Santa Rosa", "Santa Cruz", "San Miguel", "Anacapa", "San Clemente", "Santa Barbara", "Santa Catalina", "San Nicolas")) 

chis_ibis <- st_transform(chis_ibis, crs = st_crs(new_proj))

# Remove points waaaaaay off of the islands, josie-style
all_data_coords2 <- st_as_sf(all_data_coords1, coords = c("coords.x1", "coords.x2"), crs = new_proj)

all_data_coords3 <- st_join(all_data_coords2, chis_ibis, join = st_intersects) %>%
  filter(!is.na(island))

ggplot(chis_ibis) +
  geom_sf(data = all_data_coords3, color = "red", size = 0.3) +
  geom_sf(fill = alpha("black", 0.2)) 

write_csv(all_data_coords3, "Reptile/all_data_coords_clean.csv")
```

```{r Step 3. grid data download Reptile}
################# Grid maps ############
# Matrix indicating which cells from islandRaster correspond to which island
island.cells <- read.csv("Heatmap_files/islandCells.csv")

# binary raster of the islands and coastline
isl.rast <- raster("Heatmap_files/islandRaster.asc")
 
# Data
occ <- read_csv("Reptile/all_data_coords_clean.csv") 

# The xlim & ylim (in albers) for plotting each island
plot.lims <- read.csv("Heatmap_files/islandPlotLimits.csv")

```

#Make the maps
```{r grid making}
# Lines for island edges
counties <- readOGR("Heatmap_files", layer="cnty24k09_1_line")
chis_counties <- counties[counties$NAME%in%c("Ventura", "Santa Barbara","Los Angeles","San Diego","Orange")]
is.map <- crop(counties, extent(-1.5e+05,2.5e+05,-6e+05,-4e+05))


isl.names <- c("Anacapa","Santa Cruz","Santa Rosa","San Miguel",
"Santa Catalina","San Clemente","San Nicolas","Santa Barbara")

### Analysis - Build Tables/Rasters
# get cellIDs for each occurrence
cellID <- cellFromXY(isl.rast, xy = cbind(occ$Lon_alb, occ$Lat_alb))
occ <- cbind(occ,cellID); rm(cellID)
length(unique(occ$cellID))

# make a big grid
w <- which(!is.na(isl.rast[]))
taxa <- sort(unique(occ$acceptedName))
taxGrid <- matrix(nrow=length(taxa),ncol=length(w))
colnames(taxGrid) <- w
rownames(taxGrid) <- taxa
taxGrid[] <- 0

for(i in 1:dim(taxGrid)[1]){
	spCells <- occ$cellID[occ$acceptedName==taxa[i]]
	for(j in 1:length(spCells)){
		taxGrid[i,w %in% spCells[j]]<-taxGrid[i,w %in% spCells[j]]+1
	}
}

# make a binary version (this is presence/abs of each sp in each cell rather than num of collections of each sp in each cell)
binaryGrid <- taxGrid
binaryGrid[binaryGrid>0] <- 1

# make corresponding rasters
rich.rast <- isl.rast
rich.rast[rich.rast == 1] <- 0
rich.rast[w] <- colSums(binaryGrid)
coll.rast <- isl.rast
coll.rast[coll.rast == 1] <- 0
coll.rast[w] <- colSums(taxGrid)

plot(rich.rast)
plot(coll.rast)

### Calculate % Empty and Redundancy for Islands ##

k=1
is.cel <- island.cells$isl.rastCell[island.cells$island == isl.names[k]]
rich.cel <- rich.rast[is.cel]
coll.cel <- coll.rast[is.cel]

k=2
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=3
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=4
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=5
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=6
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=7
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=8
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]


coll.Summary<-matrix(nrow=8,ncol=9)

# Red =  1-R/N
rownames(coll.Summary) <- isl.names
colnames(coll.Summary) <- c("totCells","totColls","totRich","Empty","perEmpty",
                            "mnRich","mnColl","mnRedund","mnRedundwE")
for(i in 1:8){
	is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[i]]
	rich.cel<-rich.rast[is.cel]
	coll.cel<-coll.rast[is.cel]
	coll.Summary[i,"totCells"] <- length(rich.cel)
	coll.Summary[i,"totColls"] <- sum(coll.cel)
	coll.Summary[i,"Empty"] <- length(which(rich.cel==0))
	coll.Summary[i,"perEmpty"] <- round(length(which(rich.cel==0))/length(rich.cel),3)
	coll.Summary[i,"mnRich"] <- mean(rich.cel[rich.cel!=0])
	coll.Summary[i,"mnColl"] <- mean(coll.cel[rich.cel!=0])
	coll.Summary[i,"totRich"] <- length(unique(occ$Sci_Name[occ$isl_name==isl.names[i]]))
	coll.Summary[i,"mnRedund"] <- round(mean(1-(rich.cel[rich.cel!=0]/coll.cel[rich.cel!=0])),3)
	coll.Summary[i,"mnRedundwE"] <- round(1/mean((coll.cel-rich.cel)),3)
}

sum_table <- as.data.frame(coll.Summary) %>%
  rownames_to_column(var = "island") %>% 
  rename("Island Collections" ="totColls", "1 km cells" ="totCells", "Empty 1 km cells" ="Empty", "Mean records/cell"="mnColl", "Mean redundancy" ="mnRedundwE", "% empty cells"="perEmpty") %>%
  relocate("island", "Island Collections", "1 km cells", "Empty 1 km cells", "% empty cells", "Mean records/cell", "Mean redundancy" )
write.csv(sum_table, "reptile/rep_sum_table.csv", na="")

######### Make Grid-based maps ##################
colorfunc <- colorRampPalette(c("gray90","red"))
colRamp <- colorfunc(20)



### Sampling intensity
#anacapa
i=1
plot(coll.rast, col=colRamp, xlim=c(50000,61000), ylim=c(-450000,-440000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#cruz
i=2
plot(coll.rast, col = colRamp, xlim=c(5000,46000), ylim=c(-460000,-420000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#rosa
i=3
plot(coll.rast, col=colRamp, xlim=c(-25000,5000), ylim=c(-470000,-430000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#miguel
i=4
plot(coll.rast, col=colRamp,xlim=c(-45000,-25000),ylim=c(-450000,-430000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19)  
#catalina
i=5
plot(coll.rast, col=colRamp,xlim=c(125000,165000),ylim=c(-530000,-500000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19)  
#clemente
i=6
plot(coll.rast, col=colRamp,xlim=c(125000,160000),ylim=c(-580000,-550000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#nicolas
i=7
plot(coll.rast, col=colRamp,xlim=c(35000,58000),ylim=c(-540000,-520000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#barbara
i=8
plot(coll.rast, col=colRamp,xlim=c(86000,94000),ylim=c(-508000,-500000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19)

```

#Mammal data
 Lat and Long included. 
```{r selecting and combining}
mam_chis <- read_csv("mammal/mam_chis.csv")

mam_chis_coord <- mam_chis %>%
  rename(latitude = "decimalLatitude", longitude = "decimalLongitude", id="gbifID") %>%
  select(id, institutionCode, source, month, year, island, class, acceptedFamily, acceptedGenus, acceptedName, latitude, longitude, locality )

```

```{r Cleaning up data Mammals }
# create a dataframe of all complete cases of name, lat/long, island, and year with unique lat/long and locality to check, made a list of ones to remove from excel sheet

all_data_coords_mam_unclean <- mam_chis_coord %>%
  dplyr::filter(!is.na(latitude), !is.na(longitude))

mam_data = all_data_coords_mam_unclean %>% 
  unite("latlong", latitude:longitude, remove=FALSE, sep="")

mamcoord= table(mam_data$latlong)
mamcoord = as.data.frame.table(mamcoord) %>% rename(latlong="Var1")

mam_latlong = mam_data %>% select(id, island, latlong, latitude, longitude, locality, year)
mamcoord2 = left_join(mamcoord, mam_latlong) %>% rename(locality_latlong ="latlong")
mamcoord3 = distinct(mamcoord2, across(contains("locality")), .keep_all=TRUE) %>% add_column(taxa="mammal")

write_csv(mamcoord3, "coordinates/mam_coordinates_locality.csv")

#download list of ones to remove
mam_coord_remove = read_csv("coordinates/mam_coordinates_remove.csv")

all_data_coords_amph = anti_join(all_data_coords_amph, amph_coord_remove)
all_data_coord_amph_removedlist = semi_join(all_data_coords_amph, amph_coord_remove)
```



## Island heat map

```{r Step 2. Cleaning up data AMPHIBIAN}
# create a dataframe of all complete cases of name, lat/long, island, and year

all_data_coords <- mam_data %>%
  dplyr::filter(!is.na(latitude), !is.na(longitude))

############### drop points with meaningless coords - this removes any specimens that have long/lats that are not in the vicinity of the islands

########## Remove obvious georeferencing errors by hand- the 'identify' function allows you to click on a scatterplot (ie distribution map) to identify individual points. This is nice if you have a few coords out in the ocean. If you have a bunch, you'll probably want to do an intersection with island polygons, but I didn't have an island polygon file when I was doing this (the maps I used are line shapefiles, not polygons)

## JL: will do this with the coord cleaner package 

flags <- clean_coordinates(x = all_data_coords, lon = "longitude", lat = "latitude",
                          species = "acceptedName",
                          tests = c("capitals", "centroids", "equal","gbif", "institutions",
                                     "zeros"))
all_data_coords <- all_data_coords[flags$.summary,] 

all_data_coords <- all_data_coords %>%
  filter(longitude <= -118, longitude >= -120.5,
         latitude <= 34.1, latitude >= 32.7)

  
plot(all_data_coords$longitude, all_data_coords$latitude, asp=1)

# using Ben's modified code and a shapefile found online to isolate counties of interest, 
# Albers projection is used in order to have grids in km^2


counties <- readOGR("Heatmap_files", layer="cnty24k09_1_line")
chis_counties <- counties[counties$NAME%in%c("Ventura", "Santa Barbara","Los Angeles","San Diego","Orange")]
is.map <- crop(counties, extent(-1.5e+05,2.5e+05,-6e+05,-4e+05))

plot(is.map, col="black")
rm(counties)
rm(chis_counties)

####### Project Long + Lat Coords into Albers (Island maps are in Albers)
P4S.latlon <- CRS("+proj=longlat +datum=WGS84")
new_proj <- "+proj=aea +lat_1=34 +lat_2=40.5 +lat_0=0 +lon_0=-120 +x_0=0 +y_0=-4000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"

sp <- SpatialPointsDataFrame(coords = cbind(as.numeric(all_data_coords$longitude),
                                            as.numeric(all_data_coords$latitude)), 
                             data = all_data_coords, proj4string = P4S.latlon)
pointsX <- spTransform(sp, CRS(new_proj))


# attach projected points to 'all_data'
all_data_coords1 <- cbind(all_data_coords,pointsX@coords) %>%
  mutate(Lat_alb = coords.x2,
         Lon_alb = coords.x1)

### --- Remove things in the middle of the ocean --- ###
  
# Import island polygons
ibis <- st_read("Heatmap_files/Master_Islands.shp")

chis_ibis <- ibis %>%
  filter(ISL_NAME %in% c("Santa Rosa", "Santa Cruz", "San Miguel", "Anacapa", "San Clemente", "Santa Barbara", "Santa Catalina", "San Nicolas")) 

chis_ibis <- st_transform(chis_ibis, crs = st_crs(new_proj))

# Remove points waaaaaay off of the islands, josie-style
all_data_coords2 <- st_as_sf(all_data_coords1, coords = c("coords.x1", "coords.x2"), crs = new_proj)

all_data_coords3 <- st_join(all_data_coords2, chis_ibis, join = st_intersects) %>%
  filter(!is.na(island))

ggplot(chis_ibis) +
  geom_sf(data = all_data_coords3, color = "red", size = 0.3) +
  geom_sf(fill = alpha("black", 0.2)) 

write_csv(all_data_coords3, "Mammal/all_data_coords_clean.csv")
```

```{r Step 3. grid data download Mammal}
################# Grid maps ############
# Matrix indicating which cells from islandRaster correspond to which island
island.cells <- read.csv("Heatmap_files/islandCells.csv")

# binary raster of the islands and coastline
isl.rast <- raster("Heatmap_files/islandRaster.asc")
 
# Data
occ <- read_csv("Mammal/all_data_coords_clean.csv") 

# The xlim & ylim (in albers) for plotting each island
plot.lims <- read.csv("Heatmap_files/islandPlotLimits.csv")

```

#Make the maps
```{r grid making}
# Lines for island edges
counties <- readOGR("Heatmap_files", layer="cnty24k09_1_line")
chis_counties <- counties[counties$NAME%in%c("Ventura", "Santa Barbara","Los Angeles","San Diego","Orange")]
is.map <- crop(counties, extent(-1.5e+05,2.5e+05,-6e+05,-4e+05))


isl.names <- c("Anacapa","Santa Cruz","Santa Rosa","San Miguel",
"Santa Catalina","San Clemente","San Nicolas","Santa Barbara")

### Analysis - Build Tables/Rasters
# get cellIDs for each occurrence
cellID <- cellFromXY(isl.rast, xy = cbind(occ$Lon_alb, occ$Lat_alb))
occ <- cbind(occ,cellID); rm(cellID)
length(unique(occ$cellID))

# make a big grid
w <- which(!is.na(isl.rast[]))
taxa <- sort(unique(occ$acceptedName))
taxGrid <- matrix(nrow=length(taxa),ncol=length(w))
colnames(taxGrid) <- w
rownames(taxGrid) <- taxa
taxGrid[] <- 0

for(i in 1:dim(taxGrid)[1]){
	spCells <- occ$cellID[occ$acceptedName==taxa[i]]
	for(j in 1:length(spCells)){
		taxGrid[i,w %in% spCells[j]]<-taxGrid[i,w %in% spCells[j]]+1
	}
}

# make a binary version (this is presence/abs of each sp in each cell rather than num of collections of each sp in each cell)
binaryGrid <- taxGrid
binaryGrid[binaryGrid>0] <- 1

# make corresponding rasters
rich.rast <- isl.rast
rich.rast[rich.rast == 1] <- 0
rich.rast[w] <- colSums(binaryGrid)
coll.rast <- isl.rast
coll.rast[coll.rast == 1] <- 0
coll.rast[w] <- colSums(taxGrid)

plot(rich.rast)
plot(coll.rast)

### Calculate % Empty and Redundancy for Islands ##

k=1
is.cel <- island.cells$isl.rastCell[island.cells$island == isl.names[k]]
rich.cel <- rich.rast[is.cel]
coll.cel <- coll.rast[is.cel]

k=2
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=3
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=4
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=5
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=6
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=7
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]

k=8
is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[k]]
rich.cel<-rich.rast[is.cel]
coll.cel<-coll.rast[is.cel]


coll.Summary<-matrix(nrow=8,ncol=9)

# Red =  1-R/N
rownames(coll.Summary) <- isl.names
colnames(coll.Summary) <- c("totCells","totColls","totRich","Empty","perEmpty",
                            "mnRich","mnColl","mnRedund","mnRedundwE")
for(i in 1:8){
	is.cel<-island.cells$isl.rastCell[island.cells$island==isl.names[i]]
	rich.cel<-rich.rast[is.cel]
	coll.cel<-coll.rast[is.cel]
	coll.Summary[i,"totCells"] <- length(rich.cel)
	coll.Summary[i,"totColls"] <- sum(coll.cel)
	coll.Summary[i,"Empty"] <- length(which(rich.cel==0))
	coll.Summary[i,"perEmpty"] <- round(length(which(rich.cel==0))/length(rich.cel),3)
	coll.Summary[i,"mnRich"] <- mean(rich.cel[rich.cel!=0])
	coll.Summary[i,"mnColl"] <- mean(coll.cel[rich.cel!=0])
	coll.Summary[i,"totRich"] <- length(unique(occ$Sci_Name[occ$isl_name==isl.names[i]]))
	coll.Summary[i,"mnRedund"] <- round(mean(1-(rich.cel[rich.cel!=0]/coll.cel[rich.cel!=0])),3)
	coll.Summary[i,"mnRedundwE"] <- round(1/mean((coll.cel-rich.cel)),3)
}

sum_table <- as.data.frame(coll.Summary) %>%
  rownames_to_column(var = "island") %>% 
  rename("Island Collections" ="totColls", "1 km cells" ="totCells", "Empty 1 km cells" ="Empty", "Mean records/cell"="mnColl", "Mean redundancy" ="mnRedundwE", "% empty cells"="perEmpty") %>%
  relocate("island", "Island Collections", "1 km cells", "Empty 1 km cells", "% empty cells", "Mean records/cell", "Mean redundancy" )
write.csv(sum_table, "mammal/mam_sum_table.csv", na="")

######### Make Grid-based maps ##################
colorfunc <- colorRampPalette(c("gray90","red"))
colRamp <- colorfunc(20)



### Sampling intensity
#anacapa
i=1
plot(coll.rast, col=colRamp, xlim=c(50000,61000), ylim=c(-450000,-440000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#cruz
i=2
plot(coll.rast, col = colRamp, xlim=c(5000,46000), ylim=c(-460000,-420000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#rosa
i=3
plot(coll.rast, col=colRamp, xlim=c(-25000,5000), ylim=c(-470000,-430000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#miguel
i=4
plot(coll.rast, col=colRamp,xlim=c(-45000,-25000),ylim=c(-450000,-430000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19)  
#catalina
i=5
plot(coll.rast, col=colRamp,xlim=c(125000,165000),ylim=c(-530000,-500000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19)  
#clemente
i=6
plot(coll.rast, col=colRamp,xlim=c(125000,160000),ylim=c(-580000,-550000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#nicolas
i=7
plot(coll.rast, col=colRamp,xlim=c(35000,58000),ylim=c(-540000,-520000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19) 
#barbara
i=8
plot(coll.rast, col=colRamp,xlim=c(86000,94000),ylim=c(-508000,-500000),
     xaxt = "n", yaxt = "n") +
  plot(is.map, add=T) +
  points(occ$Lon_alb,occ$Lat_alb, cex=0.3, col="blue", pch=19)

```
